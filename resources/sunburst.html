<!DOCTYPE html>
<meta charset="utf-8">
<style>

 body {
     font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
     margin: auto;
     position: relative;
     width: 960px;
 }

 form {
     position: absolute;
     right: 10px;
     top: 10px;
 }

 .directory-path {
     height: 3ex;
     word-break: break-all;
 }

 .tooltip-shadow {
     fill: #000;
     opacity: 0.7;
 }

 .tooltip-label {
     text-anchor: middle;
     font-size: 12px;
 }

</style>
<body>
</body>
<script src="d3.v3.js"></script>
<script>

 var width = 960,
     height = 700,
     radius = Math.min(width, height) / 2.2,
     color = d3.scale.category20();

 color.range(color.range().map(function(oc) {
     var c = d3.hsl(oc);
     c.l = Math.max(c.l, 0.5);
     return c.darker(1);
 }));

 function arcColor(d) {
     return color((d.children ? d : d.parent).name);
 }

 function arcBrightColor(d) {
     var c = d3.hsl(arcColor(d));
     c.s = 0.8;
     c.l = 0.8;
     return c;
 }

 var svg, agroup, tgroup;

 var partition = d3.layout.partition()
                   .sort(null)
                   .size([2 * Math.PI, radius * radius])
                   .value(function(d) { return d.size; });

 var arc = d3.svg.arc()
             .startAngle(function(d) { return d.x; })
             .endAngle(function(d) { return d.x + d.dx; })
             .innerRadius(function(d) { return Math.sqrt(d.y) })
             .outerRadius(function(d) { return Math.sqrt(d.y + d.dy); });

 d3.json("../output/lz96_b.json", function(error, root) {
     if (error) throw error;
     updateData(root);
 });

 var directoryPath = d3.select("body").append("p").attr("class", "directory-path");

 function updateData(data) {
     d3.select('svg').remove();
     svg = d3.select("body").append("svg")
             .attr("width", width)
             .attr("height", height)
             .append("g")
             .attr("transform", "translate(" + width / 2 + "," + height * .5 + ")");
     agroup = svg.append("g");
     tgroup = svg.append("g").style("pointer-events", "none");
     renderData(data);
 }

 function renderData(data) {
     var asel = agroup.datum(data).selectAll("path")
                      .data(partition.nodes);
     asel
         .enter()
         .append("path")
         .attr("d", arc)
         .style("stroke-width", function(d) {
             return 3/(d.depth - data.depth);
         })
         .on("click", function(d) {
             if (d === data && d.parent !== undefined) {
                 updateData(d.parent);
             } else {
                 updateData(d);
             }
             d3.event.stopPropagation();
         })
         .on("mouseover", function(d) {
             lin_d = lineage(d);
             for (var [i, n] of lin_d.entries()) {
                 n.highlighted = true;
                 n.h_height = i;
             };
             paths = lin_d.reverse().map(function(n) { return n.name });
             directoryPath.text(paths.join("/"));
             renderData(data);
         })
         .on("mouseout", function(d) {
             for (var n of lineage(d)) {
                 n.highlighted = false;
             }
             directoryPath.text(null);
             renderData(data);
         });

     var tsel = tgroup.datum(data).selectAll("g")
                      .data(partition.nodes);

     var tsgroup = tsel.enter().append("g");

     tsgroup
         .attr("transform", function(d) {
             var a1 = rad2deg(d.x + d.dx / 2) - 90;
             var x = Math.sqrt(d.y + d.dy / 2);
             if (d === data) {
                 x = 0;
             }
             /* The starting angle of a 360-degree arc is at 90 degrees,
                putting the midpoint (and thus our tooltip) at 180. Override
                the angle to 0 for these arcs for better readability. */
             if (Math.abs(d.dx - 2 * Math.PI) < 1e-5) {
                 a1 = 0;
             }
             var y = -10, a2 = 0;
             /* For tooltips to the left of the origin, we rotate them by 180
                after the initial rotation and translation to keep them right
                side up. We also need to reverse the vertical translation as
                now the tooltip is facing the other direction. */
             if (a1 > 90 && a1 < 270) {
                 y = -y;
                 a2 = 180;
             }
             return `rotate(${a1}) translate(${x} ${y}) rotate(${a2})`;
         });

     tsgroup
         .append('rect')
         .attr('class', 'tooltip-shadow')
         .attr('rx', 2).attr('ry', 2);

     tsgroup
         .append('path')
         .attr('class', 'tooltip-shape')
         .attr('d', 'M -5 0 H 5 L 0 10 Z');

     tsgroup
         .append('rect')
         .attr('class', 'tooltip-shape')
         .attr('rx', 2).attr('ry', 2);

     tsgroup
         .append("text")
         .attr('class', 'tooltip-label')
         .text(function(d) {
             return d.name + ' - ' + formatBytes(d.value);
         });

     tsgroup
         .select("text")
         .each(function() {
             var bbox = this.getBBox();
             var psel = d3.select(this.parentNode);
             psel.selectAll("rect.tooltip-shape")
                 .attr("x", bbox.x - 3)
                 .attr("y", bbox.y)
                 .attr("width", bbox.width + 6)
                 .attr("height", bbox.height);
             psel.selectAll("rect.tooltip-shadow")
                 .attr("x", bbox.x - 5)
                 .attr("y", bbox.y + 2)
                 .attr("width", bbox.width + 10)
                 .attr("height", bbox.height);
         });

     asel
         .style("stroke", function(d) {
             return d.highlighted ? "#333" : "#eee";
         })
         .style("fill", function(d) {
             return d.highlighted ? arcBrightColor(d) : arcColor(d);
         });

     tsel
        .style("display", function(d) {
            return d.highlighted ? null : 'none';
        })
        .selectAll(".tooltip-shape")
        .style("fill", function(d) {
            var c = d3.hsl('white').darker(d.h_height * 0.25);
            return d.h_height === undefined ? null : c;
        });

     asel.exit().remove();
     tsel.exit().remove();

     d3.select('html').on("click", function() {
         var d = data;
         while (d.parent !== undefined) {
             d = d.parent;
         }
         updateData(d);
     });
 }

 function lineage(d) {
     var nodes = [d];
     while (d.parent !== undefined) {
         nodes.push(d.parent);
         d = d.parent;
     }
     return nodes;
 }

 function rad2deg(a) {
     return a * 180 / Math.PI;
 }

 var formatSI = d3.format('.3s');

 function formatBytes(b) {
     return formatSI(b) + 'B';
 }

 d3.select(self.frameElement).style("height", height + "px");

</script>
